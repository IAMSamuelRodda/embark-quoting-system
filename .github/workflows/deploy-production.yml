name: Deploy to Production

on:
  # Deploy to production only on main branch pushes (after manual approval of devâ†’main PR)
  push:
    branches: [main]
  # Allow manual triggers for emergency deployments
  workflow_dispatch:

env:
  AWS_REGION: ap-southeast-2  # Sydney region (matches deployed infrastructure)
  ECR_REPOSITORY: embark-quoting-backend
  ECS_CLUSTER: embark-quoting-production-cluster
  ECS_SERVICE: embark-quoting-production-backend-service
  ECS_TASK_DEFINITION: embark-quoting-production-backend
  CONTAINER_NAME: backend

jobs:
  deploy-backend:
    name: Deploy Backend to ECS
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://api.embark-quoting.com  # TODO: Update to your production API URL

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get latest image from ECR
        id: get-image
        run: |
          # Use 'latest' tag for production deployments (from main branch builds)
          IMAGE_TAG="latest"
          IMAGE_URI="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${IMAGE_TAG}"
          echo "image-uri=${IMAGE_URI}" >> $GITHUB_OUTPUT
          echo "Deploying image: ${IMAGE_URI}"

      - name: Download task definition
        run: |
          aws ecs describe-task-definition \
            --task-definition ${{ env.ECS_TASK_DEFINITION }} \
            --query taskDefinition \
            > task-definition.json
        # TODO: Create initial ECS task definition in AWS

      - name: Update task definition with new image
        id: task-def
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: task-definition.json
          container-name: ${{ env.CONTAINER_NAME }}
          image: ${{ steps.get-image.outputs.image-uri }}

      - name: Deploy to Amazon ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.task-def.outputs.task-definition }}
          service: ${{ env.ECS_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true
          wait-for-minutes: 10

      - name: Verify deployment
        run: |
          echo "Waiting for service to stabilize..."
          sleep 30

          # Health check using production URL (behind ALB, not public IP)
          HEALTH_URL="${{ secrets.PRODUCTION_API_URL }}/health"
          echo "Running health check on ${HEALTH_URL}"

          response=$(curl -s -o /dev/null -w "%{http_code}" $HEALTH_URL)

          if [ "$response" = "200" ]; then
            echo "âœ… Production deployment successful! Health check passed."
            echo "Backend is accessible at: $HEALTH_URL"
          else
            echo "âŒ Production deployment failed! Health check returned: $response"
            exit 1
          fi

  deploy-frontend:
    name: Deploy Frontend to S3/CloudFront
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://embark-quoting.com  # TODO: Update to your production frontend URL

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Build frontend for production
        working-directory: ./frontend
        run: npm run build
        env:
          NODE_ENV: production
          VITE_API_URL: ${{ secrets.PRODUCTION_API_URL }}
          VITE_COGNITO_USER_POOL_ID: ${{ secrets.PRODUCTION_COGNITO_USER_POOL_ID }}
          VITE_COGNITO_CLIENT_ID: ${{ secrets.PRODUCTION_COGNITO_CLIENT_ID }}
          VITE_COGNITO_REGION: ${{ env.AWS_REGION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to S3
        run: |
          aws s3 sync ./frontend/dist/ s3://${{ secrets.PRODUCTION_S3_BUCKET }}/ \
            --delete \
            --cache-control "public, max-age=31536000, immutable" \
            --exclude "index.html" \
            --exclude "service-worker.js"

          # Cache index.html and service-worker.js for shorter time
          aws s3 cp ./frontend/dist/index.html s3://${{ secrets.PRODUCTION_S3_BUCKET }}/index.html \
            --cache-control "public, max-age=0, must-revalidate"

          if [ -f ./frontend/dist/service-worker.js ]; then
            aws s3 cp ./frontend/dist/service-worker.js s3://${{ secrets.PRODUCTION_S3_BUCKET }}/service-worker.js \
              --cache-control "public, max-age=0, must-revalidate"
          fi
        # TODO: Create S3 bucket for production frontend

      - name: Invalidate CloudFront cache
        run: |
          aws cloudfront create-invalidation \
            --distribution-id ${{ secrets.PRODUCTION_CLOUDFRONT_ID }} \
            --paths "/*"
        # TODO: Create CloudFront distribution for production

      - name: Verify frontend deployment
        run: |
          echo "Waiting for CloudFront invalidation..."
          sleep 30

          # Check if index.html is accessible
          response=$(curl -s -o /dev/null -w "%{http_code}" ${{ secrets.PRODUCTION_FRONTEND_URL }})

          if [ "$response" = "200" ]; then
            echo "âœ… Frontend deployment successful!"
          else
            echo "âŒ Frontend deployment failed! Response: $response"
            exit 1
          fi

  smoke-tests:
    name: Run Production Smoke Tests
    runs-on: ubuntu-latest
    if: ${{ !cancelled() }}
    needs: [deploy-backend, deploy-frontend]
    timeout-minutes: 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Install Playwright browsers
        working-directory: ./frontend
        env:
          DEBIAN_FRONTEND: noninteractive
        run: |
          sudo mkdir -p /etc/dpkg/dpkg.cfg.d
          echo 'path-exclude=/usr/share/man/*' | sudo tee /etc/dpkg/dpkg.cfg.d/01_nodoc
          npx playwright install --with-deps chromium

      - name: Run smoke tests on production
        working-directory: ./frontend
        timeout-minutes: 3
        run: |
          echo "ðŸ” Production Smoke Test Configuration:"
          echo "  Frontend URL: ${{ secrets.PRODUCTION_FRONTEND_URL }}"
          echo "  API URL: ${{ secrets.PRODUCTION_API_URL }}"
          echo ""

          echo "ðŸŒ Testing frontend connectivity..."
          if curl -f -s -o /dev/null -w "HTTP %{http_code} in %{time_total}s\n" "${{ secrets.PRODUCTION_FRONTEND_URL }}"; then
            echo "âœ… Frontend is reachable"
          else
            echo "âŒ Frontend is not reachable"
            exit 1
          fi

          echo "ðŸŒ Testing API health..."
          if curl -f -s -o /dev/null -w "HTTP %{http_code} in %{time_total}s\n" "${{ secrets.PRODUCTION_API_URL }}/health"; then
            echo "âœ… API is healthy"
          else
            echo "âŒ API health check failed"
            exit 1
          fi

          echo "ðŸ§ª Running critical path smoke tests (auth validation only)..."
          npm run test:e2e:validation
        env:
          E2E_BASE_URL: ${{ secrets.PRODUCTION_FRONTEND_URL }}
          E2E_API_URL: ${{ secrets.PRODUCTION_API_URL }}
          E2E_TEST_USER_EMAIL: ${{ secrets.PRODUCTION_TEST_USER_EMAIL }}
          E2E_TEST_USER_PASSWORD: ${{ secrets.PRODUCTION_TEST_USER_PASSWORD }}
        # TODO: Create smoke test user in production Cognito
        # TODO: Add production test credentials to GitHub Secrets

      - name: Upload smoke test report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: smoke-test-report-production-${{ github.sha }}
          path: frontend/playwright-report/
          retention-days: 90

  lighthouse:
    name: Lighthouse Performance Audit
    runs-on: ubuntu-latest
    if: ${{ !cancelled() }}
    needs: [deploy-frontend]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Lighthouse CI
        uses: treosh/lighthouse-ci-action@v10
        with:
          urls: |
            ${{ secrets.PRODUCTION_FRONTEND_URL }}
            ${{ secrets.PRODUCTION_FRONTEND_URL }}/quotes
          temporaryPublicStorage: true

      - name: Check Lighthouse scores
        run: |
          echo "âœ… Lighthouse audit complete. Check artifacts for detailed report."
          echo "Production performance targets:"
          echo "  - Performance: 90+"
          echo "  - Accessibility: 95+"
          echo "  - Best Practices: 95+"
          echo "  - SEO: 95+"
        # TODO: Add automated score enforcement with stricter thresholds for production

  notify-deployment:
    name: Send Deployment Notification
    runs-on: ubuntu-latest
    if: always()
    needs: [deploy-backend, deploy-frontend, smoke-tests]

    steps:
      - name: Check deployment status
        id: status
        run: |
          if [ "${{ needs.deploy-backend.result }}" = "success" ] && \
             [ "${{ needs.deploy-frontend.result }}" = "success" ] && \
             [ "${{ needs.smoke-tests.result }}" = "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "message=âœ… Production deployment successful!" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "message=âŒ Production deployment failed!" >> $GITHUB_OUTPUT
          fi

      - name: Log deployment summary
        run: |
          echo "${{ steps.status.outputs.message }}"
          echo ""
          echo "Deployment Details:"
          echo "  - Backend: ${{ needs.deploy-backend.result }}"
          echo "  - Frontend: ${{ needs.deploy-frontend.result }}"
          echo "  - Smoke Tests: ${{ needs.smoke-tests.result }}"
          echo "  - Commit: ${{ github.sha }}"
          echo "  - Triggered by: ${{ github.actor }}"
        # TODO: Add Slack/email notifications for production deployments
        # TODO: Add deployment tracking to monitoring/observability platform
